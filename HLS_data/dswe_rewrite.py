#  Required inputs for DSWE are LSRP data, the CFMask file generated by EROS, percent slope and hillshade
#   The input file directory should contain subdirectories in which all the geotiff formatted bands of a single
#  input scene have been extracted from their zip files and are stored in seperate folders.
#  Naming conventions of these files must not be edited in ANY way!  Use the default filenames as they were distributed by EROS.
#   04/28/2017
#  With this version, a percent slope file for the US is stored at the top level of the input directory. And hillshade data
#   calculated using the scene-specific solar geometry included in the mtl or xml file is included in
#   the same folder as each set of unzipped LSRP file associated with each scene. 
# This data derived from the DEM should be at 30m spatial resolution, snapped to your Landsat image and MUST be projected to match
#   the Landsat UTM zone.  It should be slighlty larger than your path/row.
# 
#
# *****************VARIABLE DECLARATIONS***********************************
#
# Input (data) variables
# BLUE = Landsat TM/ETM Band 1 or OLI Band 2
# GREEN = Landsat TM/ETM Band 2 or OLI Band 3 
# NIR = Landsat TM/ETM Band 4 or OLI Band 5
# SWIR1 = Landsat TM/ETM Band 5 or OLI Band 6 
# SWIR2 = Landsat TM/ETM Band 7 or OLI Band 7
# CF= Landsat Cfmask- Cloud, Cloud Shadow, and Snow Mask distributed with LSRP data

import numpy as np
import gdal
import os
import datetime
import glob
import argparse


WIGT = 0.124
AWGT = 0
AWE_param1 = 2.5
AWE_param2 = -1.5
AWE_param3 = -0.25
PSW1_MNDWI = -0.44
PSW1_NIR = 1500
PSW1_SWIR1 = 900
PSW1_NDVI = 0.7
PSW2_MNDWI = -0.5
PSW2_BLUE = 1000
PSW2_NIR = 2500
PSW2_SWIR1 = 3000
PSW2_SWIR2 = 1000
# Cutoff value for hillshade, values for hillshade range from 1-255, the lower the more shaded.
HS=110



def percent_slope_horn(elevation_band):

    return percent_slope_band


def percent_slope_zeven_thorne(elevation_band):

    return percent_slope_band

def hillshade(elevation_band, sun_altitude, sun_azimuth):

    return hillshade_band

def diagnostic_setup(blue, green, red, nir, swir1, swir2):
    '''
    input bands as np arrays
    '''
    # calculate indexes for non-fill (valid) pixels:

    # Modified Normalized Difference Wetness Index
    mndwi = (green - swir1) / (green + swir1)
    # Multi-band Spectral Relationship Visible
    mbsrv = green + red
    # Multi-band Spectral Relationship Near-Infrared
    mbsrn = nir + swir1
    # Automated Water Extent Shadow
    awesh = blue + (2.5 * green) - (1.5 * mbsrn) - (0.25 * swir2)
    # Normalized Difference Vegetation Index
    ndvi = (nir - red) / (nir + red)

    return mndwi, mbsrv, mbsrn, awesh, ndvi

def diagnostic_tests(shape, mndwi, mbsrv, mbsrn, awesh, ndvi):

   #XXX get const values in here!! (eg wigt, pswt, etc) 

    # perform 5 diagnostic tests:
    # test 1
    test1 = np.full(shape, False, dtype=bool)
    test1[mndwi > wigt] = True

    # test 2
    test2 = np.full(shape, False, dtype=bool)
    test2[mbsrv > mbsrn] = True

    # test 3
    test3 = np.full(shape, False, dtype=bool)
    test3[awesh > awgt] = True

    # test 4
    test4 = np.full(shape, False, dtype=bool)
    test4[(mndwi > pswt_1_mndwi) & 
            (swir1 < pswt_1_swir1) &
            (nir < pswt_1_nir) &
            (ndvi < pswt_1_ndvi)] = True

    # test 5
    test5 = np.full(shape, False, dtype=bool)
    test4[(mndwi > pswt_2_mndwi) & 
            (blue < pswt_2_blue) &
            (swir1 < pswt_2_swir1) &
            (swir2 < pswt_2_swir2) &
            (nir < pswt_1_nir)] = True

    # stack the results together
        # (so each pixel has a list of 5 bools)
    diag = np.stack((test1, test2, test3, test4, test5), axis=-1)

    return diag


def recode_to_interpreted(diag, shape):
    sum_passed = np.sum(diag, axis=-1)

    assert sum_true.shape == shape

    intr = np.empty(shape, dtype=int)
    
    # not water (0 or 1 tests passed)
    intr[(sum_passed == 0) | (sum_passed == 1)] = 0

    # water - high confidence (4 or 5 tests passed)
    intr[(sum_passed == 4) | (sum_passed == 5)] = 1

    # water - moderate confidence (3 tests passed)
    intr[sum_passed == 3] = 2

    # potential wetland - tests 1 and 2 passed
    # delete all but first 2 tests for each pixel
    sum_1_2 = np.delete(diag, np.s_[2:], -1)
    sum_1_2 = np.sum(sum_1_2, axis=-1)

    intr[(sum_1_2 == 2) & (sum_passed == 2)] = 3

    # low confidence water or wetland - 2 tests passed
        # (except not both 1 and 2)
    intr[(sum_passed == 2) & (sum_1_2 != 2)] = 4


    #TODO make sure that 255 (fill values) are accounted for!!!!!!!!!!!!

    return intr

def save_output_tif(data, filename, geo_transform, projection):
    '''
    
    INPUTS:
        data : numpy array : data to save
        filename : str : full path and filename for output file
        geo_transform : tuple : raster coordinates related to
            georeferencing coordinates by affine transform
        projection : list : GDAL projection metadata
    RETURNS:
        output file saved as filename
    '''
    shape = array.shape
    driver = gdal.GetDriverByName('GTiff')

    outdata = driver.Create(filename, shape[1], shape[0], 1, gdal.GDT_Byte)
    outdata.SetGeoTransform(geo_transform)
    outdata.SetProjection(projection)
    outdata.GetRasterBand(1).SetNoDataValue(255)
    outdata.GetRasterBand(1).WriteArray(data)
    outdata.FlushCache()



def main(input_dir, output_dir, **kwargs):
    '''
    INPUTS:
        input_dir : str : path to directory with input data
        output_dir : str : output directory for interpreted band,
            mask band, interpreted band with masking, and optional
            diagnostic band, percent slope, and hillshade
    OPTIONAL INPUTS:
        include_tests : bool : if flagged, save results of diagnostic 
            tests to a file
        include_ps : bool : if flagged, save percent slope to a file
        include_hs : bool : if flagged, save hillshade (shaded relief)
            to a file
        use_zeven_thorne : bool : if flagged, use Zevenbergen and
            Thorne's slope algorithm; otherwise, defaults to Horn's
            slope algorithm
        use_toa : bool : if flagged, Top of Atmosphere (TOA)
            reflectance is used; otherwise, defaults to Surface
            Reflectance
        
    RETURNS:
    '''
    

    #os.chdir(input_dir)

    # there will be multiple folders
        # each with landsat/hls tiff bands + hlsd/slp/dem


    # need 2 options -- one for existing landsat tiffs
    # one for feeding hls bands directly into code


    # make a list of subdirs (each landsat tile)
    subdirs = [f.path for f in os.scandir(input_dir) if f.is_dir()]


    #XXX needed? better way that isn't filenames?
    # find percent slope file (should be in top dir)
    files = [f.path for f in os.scandir(input_dir) if os.path.isfile(f)]
    per_slope_str = 'perslp'
    for file in files:
        if per_slope_str in file:
            percent_slope = file
        #XXX what to do if no percent slope file?



    # for each subdir (separate HLS/landsat scene)
    for input_subdir in subdirs:
        # make an output subdir
        output_subdir = os.path.join(output_dir, input_subdir)
        os.makedirs(output_subdir, exist_ok=True)

        # get bands
        files = [f.path for f in os.scandir(input_subdir) if os.path.isfile(f)]
        for filename in files:

            if targz: # landsat data
                def file_to_array(filename):
                    '''
                    Open file as gdal dataset, get geo transform and
                    projection, convert to numpy array.
                    '''
                    data = gdal.Open(filename)
                    geo_transform = data.GetGeoTransform()
                    projection = data.GetProjection()
                    array = data.GetRasterBand(1).ReadAsArray()
                    return array, geo_transform, projection

                if 'B2' in filename:
                    blue, blue_geo, blue_proj = file_to_array(filename)
                if 'B3' in filename:
                    green, green_geo, green_proj = file_to_array(filename)
                if 'B4' in filename:
                    red, red_geo, red_proj = file_to_array(filename)
                if 'B5' in filename:
                    nir, nir_geo, nir_proj = file_to_array(filename)
                if 'B6' in filename:
                    swir1, swir1_geo, swir1_proj = file_to_array(filename)
                if 'B7' in filename:
                    swir2, swir2_geo, swir2_proj = file_to_array(filename)

                # assert all bands have the same geo transform, 
                    # projection, and shape
                assert (blue_geo == green_geo == red_geo == nir_geo ==
                            swir1_geo == swir2_geo)
                assert (blue_proj == green_proj == red_proj == nir_proj ==
                            swir1_proj == swir2_proj)
                assert (blue.shape == green.shape == red.shape == nir.shape ==
                            swir1.shape == swir2.shape)

                # assign geo transform, projection, and shape
                geo_transform = blue_geo
                projection = blue_proj
                shape = blue.shape

                #XXX this works for landsat 8, but what about other landsat?
                    #XXX what are B6_VCID_1 and 2 in LE07 tar file??
            else: #HLS data
                #XXX find out what to do here to get bands!!
                # read from TIFF or get from read_hls!!
                pass 
            #TODO what is the CF mask????????????????
            #XXX use to get no data pixels






        # calculate indexes for diagnostic tests
        mndwi, mbsrv, mbsrn, awesh, ndvi = diagnostic_setup(blue, 
                                        green, red, nir, swir1, swir2)
        diag = diagnostic_tests(shape, mndwi, mbsrv, mbsrn, awesh, ndvi)
        
        if include_tests:
            # save diag to TIF
            diag_filename = os.path.join(output_subdir, 'DIAG.tif') #XXX better filename -- landsat_id_info_DIAG.TIF
            save_output_tif(diag, diag_filename, geo_transform, projection)

        # recode to interpreted DSWE
        intr = recode_to_interpreted(diag, shape)

        # save intr to TIF


    return





def old_code():
    for folder in paths:
        out_name = 'DSWE_V2_P1'
        
        # Terrain Correction, here we are simply recoding slopes >=x degrees to PS (specified above), which will be reclassified as non-water.

        perslp = gdal.Open(Perslp)
        #Get extent and projection
        perslpgeo = perslp.GetGeoTransform()
        perslpproj = perslp.GetProjection()
        # Calculate percent slope
        #perslp= perslp.GetRasterBand(1).ReadAsArray()
        os.chdir(working_dir)
        CF = gdal.Open(CF)
        #Get extent of CF mask (and our LS image by proxy)
        geoTransform = CF.GetGeoTransform()
        minx = geoTransform[0]
        maxy = geoTransform[3]
        maxx = minx + geoTransform[1] * CF.RasterXSize
        miny = maxy + geoTransform[5] * CF.RasterYSize
        #Clip our slope and hillshade mask to the image (have to do this for each image due to the variable extents of each image)
        GeoClip= [minx, maxy, maxx, miny]
        hillshade= gdal.Open(Hillshade)
        perslp_clip=gdal.Translate('perslp_clip.tif', perslp, projWin = GeoClip)
        hillshade_clip=gdal.Translate('hillshade_clip.tif', hillshade, projWin = GeoClip)
        hillshade= hillshade_clip.GetRasterBand(1).ReadAsArray()
        hillshade[hillshade <= HS] = 0
        hillshade[hillshade > HS] = 1
        
        #Read in the slope and hillshade masks and convert to an array
        workingoutput_dir=output_dir2 + "\\" + directory
        if not os.path.exists(workingoutput_dir):
            os.makedirs(workingoutput_dir)
            
        #calculate our unmasked diagnostic map
        CF= CF.GetRasterBand(1).ReadAsArray()
        diagoutput=output_dir2 +  "\\" + directory + "\\" + out_name + "_diag" + "_%s.tif"%"_".join(raster.split('_'))[0:length]
        diagmap[np.where((CF == 255))] = -9999
        diagmap_out = driver.Create( diagoutput, shape[1], shape[0], 1, gdal.GDT_Int16)
        diagmap_out.SetGeoTransform( geo )
        diagmap_out.SetProjection( proj )
        diagmap_out.GetRasterBand(1).WriteArray(diagmap)
        diagmap_out.GetRasterBand(1).SetNoDataValue(-9999)
            
        
        # Output unmasked interpreted map
        interpoutput=output_dir2 +  "\\" + directory + "\\" + out_name + "_interp" + "_%s.tif"%"_".join(raster.split('_'))[0:length]
        interpmap=diagmap.copy()
        interpmap[np.where((diagmap == 0) | (diagmap == 1) | (diagmap == 10) | (diagmap == 100) | (diagmap == 1000))] = 0
        interpmap[np.where((diagmap == 1111) | (diagmap == 10111) | (diagmap == 11011) | (diagmap == 11101) | (diagmap == 11110) | (diagmap == 11111)) ] = 1
        interpmap[np.where((diagmap == 111) | (diagmap == 1011) | (diagmap == 1101) | (diagmap == 1110) | (diagmap == 10011) | (diagmap == 10101) | (diagmap == 10110) | (diagmap == 11001) | (diagmap == 11010) | (diagmap == 11100)) ] = 2
        interpmap[np.where((diagmap == 11000)) ] = 3
        interpmap[np.where((diagmap == 11) | (diagmap == 101) | (diagmap == 110) | (diagmap == 1001) | (diagmap == 1010) | (diagmap == 1100) | (diagmap == 10000) | (diagmap == 10001) | (diagmap == 10010) | (diagmap == 10100)) ] = 4
        interpmap[np.where((diagmap == -9999)) ] = 255
        interpmap_out = driver.Create( interpoutput, shape[1], shape[0], 1, gdal.GDT_Byte)
        interpmap_out.SetGeoTransform( geo )
        interpmap_out.SetProjection( proj )
        interpmap_out.GetRasterBand(1).WriteArray(interpmap)
        interpmap_out.GetRasterBand(1).SetNoDataValue(255)


        # Mask interpreted map using the slope file
        perslp= perslp_clip.GetRasterBand(1).ReadAsArray()
        interpmap_copy=interpmap.copy()
        interpmap[np.where((perslp >= 30) & (interpmap == 2))] = 0
        interpmap[np.where((perslp >= 20) & (interpmap == 3))] = 0
        interpmap[np.where((perslp >= 10) & (interpmap == 4))] = 0
        interpmap[np.where((perslp >= 30) & (interpmap == 1))] = 0
        interpmap_masked= interpmap * hillshade           


        
        #Cloud and snow masking and outputing masked interpreted layer
        interpmaskoutput=output_dir2 +  "\\" + directory + "\\" + out_name + "_interp_masked" + "_%s.tif"%"_".join(raster.split('_'))[0:length]
        interpmap_masked=interpmap_masked.copy()
        interpmap_masked[np.where((CF == 255))] = 255
        interpmap_masked[np.where((CF >= 2) & (CF < 255))] = 9
        interpmap_masked_out = driver.Create( interpmaskoutput, shape[1], shape[0], 1, gdal.GDT_Byte)
        interpmap_masked_out.SetGeoTransform( geo )
        interpmap_masked_out.SetProjection( proj )
        interpmap_masked_out.GetRasterBand(1).WriteArray(interpmap_masked)
        interpmap_masked_out.GetRasterBand(1).SetNoDataValue(255)
        del interpmap_masked_out
        del diagmap
        del interpmap



        #Create a full mask layer
        CF[np.where((CF == 1)) ] = 0
        perslp[np.where((perslp < 10) & (interpmap_copy == 4)) ] = 0
        perslp[np.where((perslp < 20) & (interpmap_copy == 3)) ] = 0
        perslp[np.where((perslp < 30) & (interpmap_copy == 2)) ] = 0
        perslp[np.where((perslp < 30) & (interpmap_copy == 1)) ] = 0
        perslp[np.where((perslp >= 10) & (interpmap_copy == 4)) ] = 10
        perslp[np.where((perslp >= 20) & (interpmap_copy == 3)) ] = 10
        perslp[np.where((perslp >= 30) & (interpmap_copy == 2)) ] = 10
        perslp[np.where((perslp >= 30) & (interpmap_copy == 1)) ] = 10
        perslp[np.where((interpmap_copy == 0)) ] = 0       
        hillshade[np.where((hillshade == 0)) ] = 20
        hillshade[np.where((hillshade == 1)) ] = 0
        MaskLayer=CF + perslp + hillshade
        MaskLayerOut=output_dir2 +  "\\" + directory + "\\" + out_name + "_MaskLayer" + "_%s.tif"%"_".join(raster.split('_'))[0:length]
        MaskLayer[np.where((CF == 255))] = 255
        MaskLayer_Output = driver.Create(MaskLayerOut, shape[1], shape[0], 1, gdal.GDT_Byte)
        MaskLayer_Output.SetGeoTransform( geo )
        MaskLayer_Output.SetProjection( proj )
        MaskLayer_Output.GetRasterBand(1).WriteArray(MaskLayer)
        MaskLayer_Output.GetRasterBand(1).SetNoDataValue(255)
        del hillshade_clip, hillshade, MaskLayer, CF, MaskLayerOut, MaskLayer_Output, diagoutput
        del Metadata, diagmap_out, interpmap_masked, interpmap_out, interpmaskoutput, interpoutput, perslp, perslp_clip           

#XXX command line options for later  
if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=(''))

    #XXX add required arguments here
    parser.add_argument('input_dir',
            metavar='INPUT_DIRECTORY',
            type=str,
            help='path to directory with input data')
    parser.add_argument('output_dir',
            metavar='OUTPUT_DIRECTORY',
            type=str,
            help='output directory for interpreted band, mask band, interpreted band with masking, and optional diagnostic band, percent slope, and hillshade')
    

    # options from documentation
    parser.add_argument('--include_tests',
            dest='include_tests',
            action='store_true',
            help='if flagged, save results of diagnostic tests to a file')
    parser.add_argument('--include_ps',
            dest='include_ps',
            action='store_true',
            help='if flagged, save percent slope to a file')
    parser.add_argument('--include_hs',
            dest='include_hs',
            action='store_true',
            help='if flagged, save hillshade (shaded relief) to a file')
    parser.add_argument('--use_zeven_thorne',
            dest='use_zeven_thorne',
            action='store_true',
            help=('if flagged, use Zevenbergen and Thorne\'s slope '
            'algorithm; otherwise, defaults to Horn\'s slope algorithm'))
    parser.add_argument('--use_toa',
            dest='use_toa',
            action='store_true',
            help=('if flagged, Top of Atmosphere (TOA) reflectance is '
            'used; otherwise, defaults to Surface Reflectance'))

    parser.add_argument('--verbose',
            dest='verbose',
            action='store_true',
            help='if flagged, more detailed intermediate messages are printed')

    args = parser.parse_args()
    main(**vars(args))
