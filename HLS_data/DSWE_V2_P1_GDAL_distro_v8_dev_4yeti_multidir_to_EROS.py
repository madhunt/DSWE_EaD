#Script to generate DSWE Version 2 Prototype 1 (V2_P1) Open Source Distribution Version 2 (distro_v3)
#
#
#
# *****************DEPENDENCIES*******************************************
# Python 2.7 64 bit, will not run on 32 bit Python
# GDAL 2.1+
# numpy 1.12
# lxml 3.7+
#
# *****************REVISION HISTORY*************************************** 
# Initiated on 08/13/16 by John W. Jones.
# Modified on 8/15/16 by Jacob Shermeyer to improve efficiency and activate
#  recoding scheme to produce the interpreted layer.
# Modified on 11/08/16 by John W. Jones to improve documentation as well as
#  revise the recode scheme to produce revised interpreted layer.
# Modified on 11/14/2016 to add slope masking.
# Modified on 1/18/2017 to enhance processing speed and remove a few unnecessary items
# Modified on 2/22/2017 to change to open source implementation (GDAL and numpy)
# Modified through March and April 2017 to add hillshade, modify slope masking, and update to the 
#   new SR naming convention
# Modified April 27-28 2017 to remove NLCD masking, remove redundant opening and closing of files,
#   generally improve performance, and change output bands to only those that will be distributed.
#   Note also, that the calculation of percent slope and hillshade layers are assumed to occur
#   outside of this code (in a pre-processing program).
#
# *****************INPUT FILE STRUCTURE***********************************
#  Required inputs for DSWE are LSRP data, the CFMask file generated by EROS, percent slope and hillshade
#   The input file directory should contain subdirectories in which all the geotiff formatted bands of a single
#  input scene have been extracted from their zip files and are stored in seperate folders.
#  Naming conventions of these files must not be edited in ANY way!  Use the default filenames as they were distributed by EROS.
#   04/28/2017
#  With this version, a percent slope file for the US is stored at the top level of the input directory. And hillshade data
#   calculated using the scene-specific solar geometry included in the mtl or xml file is included in
#   the same folder as each set of unzipped LSRP file associated with each scene. 
# This data derived from the DEM should be at 30m spatial resolution, snapped to your Landsat image and MUST be projected to match
#   the Landsat UTM zone.  It should be slighlty larger than your path/row.
# 
#
# *****************VARIABLE DECLARATIONS***********************************
#
# Input (data) variables
# BLUE = Landsat TM/ETM Band 1 or OLI Band 2
# GREEN = Landsat TM/ETM Band 2 or OLI Band 3 
# NIR = Landsat TM/ETM Band 4 or OLI Band 5
# SWIR1 = Landsat TM/ETM Band 5 or OLI Band 6 
# SWIR2 = Landsat TM/ETM Band 7 or OLI Band 7
# CF= Landsat Cfmask- Cloud, Cloud Shadow, and Snow Mask distributed with LSRP data
#
# *****************CALCULATED VARIABLES ON WHICH DECISIONS ARE MADE*********
#
# NDVI = Normalized Difference Vegetation Index
# MNDWI = Modified Normalized Difference Wetness Index
# MBSRV = Multiband Spectral Relationship Visible
# MBSRN = Multiband Spectral Relationship Near-infrared
# AWEsh = Automated raster Extent Shadow
# PSW1 = Partial Surface Water 1
# PSW2 = Partial Surface Water 2
#
# *****************OUTPUT INFORMATION*****************************
# Diagnostic layer- Layer indicating the combination of outcomes of the 5 water tests
# Interpreted layer- Interpretation of the diagnostic layer:
#     0= Non-Water, 1= High Confidence water, 2= Medium Confidence Water, 3= Potential Wetland, 4= Low Confidence Water or Wetland
# Masked Interpreted layer- Cloud, Snow, Slope, and Hillshade
# Mask Layer- A combination of all masks, combinations of these values indicate a pixel was masked multiple times:
# 0- No masks applied
# 2- CFMask Cloud Shadow Mask
# 3- CFMask Snow Mask
# 4- CFMask Cloud Mask
# 10- Slope Mask
# 20- Hillshade Mask
# 30- Slope and Hillshade Combination Mask



#Imports
import numpy as np
import gdal
import os
import datetime
import glob
import sys
from lxml import etree


# ******************REQUIRED INPUT PARAMETERS******************************** 
WIGT = 0.124
AWGT = 0
AWE_param1 = 2.5
AWE_param2 = -1.5
AWE_param3 = -0.25
PSW1_MNDWI = -0.44
PSW1_NIR = 1500
PSW1_SWIR1 = 900
PSW1_NDVI = 0.7
PSW2_MNDWI = -0.5
PSW2_BLUE = 1000
PSW2_NIR = 2500
PSW2_SWIR1 = 3000
PSW2_SWIR2 = 1000
# Cutoff value for hillshade, values for hillshade range from 1-255, the lower the more shaded.
HS=110



# ***************************REQUIRED PATH INFORMATION**************************
# Specify the path for input and output data,  remember to use / insted of \ if there are any numbers in the path
input_dir = "H:\DSWE\DSWE_V2\Cal_Val_Inputs_subset"
output_dir = "H:\DSWE\DSWE_V2\Cal_Val_Outputs_subset"



# ***************************REQUIRED SLOPE INFORMATION**************************
# Slope file you have created must be stored in the input_dir along with the LSRP data
# The file must have the word "perslp" anywhere in the filename and be a .tif image.


#Set the overwrite & output environment
driver = gdal.GetDriverByName("GTiff")
os.chdir(input_dir)
paths = glob.glob('*/')
print paths
for folder in paths:
    output_dir2=output_dir + "/" + folder
    if not os.path.exists(output_dir2):
        os.makedirs(output_dir2)   
    folder=os.path.join(input_dir,folder)
    os.chdir(folder)
    # Identify our percent slope file
    PerSlpL=[]
    PerSlpL=glob.glob('*perslp*.tif')
    if len(PerSlpL) > 1 or len(PerSlpL) < 1:
        print "multiple or no PerSlpL files, please place only one PerSlpL file in the LSRP input_dir"
        exit()
    else:
        print "Using PerSlpL file:"
        print PerSlpL[0]
        Perslp= os.path.abspath(PerSlpL[0])
        print Perslp
    count = 1
    #Loop through the input directory and identitify our LSRP scenes and save them to the list
    print datetime.datetime.now()
    subdirs= glob.glob('*/')
    print('Found directories: %s' % subdirs)
    subdirnumber=0
    subdirnumber+= len(subdirs)
    print subdirnumber
    cwd = os.getcwd()
    print cwd
    if count <= subdirnumber:
        T1=datetime.datetime.now()
        for directory in subdirs:
            print ""
            print ""
            print ""
            working_dir=folder + "//" + directory
            print working_dir
            os.chdir(working_dir)
            inputRaster = []
            inputRaster= glob.glob('L*')
            print inputRaster
          
            #Identify bands  based upon satellite
            for raster in inputRaster:
                filetrim=raster[:5]
                numtrim=filetrim[4:]
                if numtrim == "_":
                    filetrim=raster[:4]
                    numtrim=filetrim[3:]
                    LSnum=int(numtrim)
                    length=40
                    length2=21
                else:
                    filetrim=raster[:3]
                    numtrim=filetrim[2:]
                    LSnum=int(numtrim)
                    length=21
                    length2=13
                    
            #Landsat 4,5, and 7
                if LSnum<=7 :
                    Blue= working_dir +  '\%s_sr_band1.tif'%(raster)[0:length]
                    Green= working_dir +  '\%s_sr_band2.tif'%(raster)[0:length]
                    Red= working_dir +  '\%s_sr_band3.tif'%(raster)[0:length]
                    NIR= working_dir +  '\%s_sr_band4.tif'%(raster)[0:length]
                    SWIR1= working_dir +  '\%s_sr_band5.tif'%(raster)[0:length]
                    SWIR2= working_dir +  '\%s_sr_band7.tif'%(raster)[0:length]
                    CF = working_dir + '\%s_cfmask.tif'%(raster)[0:length]
                    Hillshade= working_dir + '\%s_hillshade.tif'%(raster)[0:length]
                    Metadata = working_dir + '\%s.xml'%(raster)[0:length]
                    yeartrim=raster[:length2]
                    year=yeartrim[-4:]
                    year=int(year)
            #Landsat 8
                elif LSnum==8:
                    Blue= working_dir +  '\%s_sr_band2.tif'%(raster)[0:length]
                    Green= working_dir +  '\%s_sr_band3.tif'%(raster)[0:length]                
                    Red= working_dir +  '\%s_sr_band4.tif'%(raster)[0:length]
                    NIR= working_dir +  '\%s_sr_band5.tif'%(raster)[0:length]
                    SWIR1= working_dir +  '\%s_sr_band6.tif'%(raster)[0:length]
                    SWIR2= working_dir +  '\%s_sr_band7.tif'%(raster)[0:length]
                    CF = working_dir + '\%s_cfmask.tif'%(raster)[0:length]
                    Hillshade= working_dir + '\%s_hillshade.tif'%(raster)[0:length]
                    Metadata = working_dir + '\%s.xml'%(raster)[0:length]
                    yeartrim=raster[:length2]
                    year=yeartrim[-4:]
                    year=int(year)
                else:
                    print "Wrong satellite or wonky input, check data."
                    quit()
                out_name = 'DSWE_V2_P1'

            # Perform Water Index (MNDWI only based) Test- Working
            GreenB= gdal.Open(Green)
            SWIR1B= gdal.Open(SWIR1)
            geo = GreenB.GetGeoTransform()  
            proj = GreenB.GetProjection()
            GreenB= GreenB.GetRasterBand(1).ReadAsArray()
            SWIR1B= SWIR1B.GetRasterBand(1).ReadAsArray()
            shape = GreenB.shape
            MNDWI = ((GreenB - SWIR1B) /np.float32(GreenB + SWIR1B))
            con_MNDWI=MNDWI.copy()
            con_MNDWI[con_MNDWI <= WIGT] = 0
            con_MNDWI[con_MNDWI > WIGT] = 1
            con_MNDWI=np.int8(con_MNDWI)
            #Optional to output MNDWI test
            #con_MNDWI1_out = driver.Create( "con_MNDWI1.tif", shape[1], shape[0], 1, gdal.GDT_UInt16)
            #con_MNDWI1_out.SetGeoTransform( geo )
            #con_MNDWI1_out.SetProjection( proj ) 
            #con_MNDWI1_out.GetRasterBand(1).WriteArray(con_MNDWI)
            #con_MNDWI1_out=None                                                   

            # Perform MBSR Test- Working
            RedB= gdal.Open(Red)
            RedB= RedB.GetRasterBand(1).ReadAsArray()
            MBSV = (GreenB + RedB)
            NIRB= gdal.Open(NIR)
            NIRB= NIRB.GetRasterBand(1).ReadAsArray()
            MBSRN = (NIRB + SWIR1B)
            con_MBSR=np.zeros(shape)
            con_MBSR[MBSV > MBSRN] = 10
            con_MBSR=np.int8(con_MBSR)
            del MBSV
            #Optional to output MBSR test
            #con_MBSR_out = driver.Create( "con_MBSR.tif", shape[1], shape[0], 1, gdal.GDT_UInt16)
            #con_MBSR_out.SetGeoTransform( geo )
            #con_MBSR_out.SetProjection( proj ) 
            #con_MBSR_out.GetRasterBand(1).WriteArray(con_MBSR)
            #con_MBSR_out=None

            #Calculate AWEsh values- working
            con_AWEsh = (np.float32(GreenB) * AWE_param1)
            con_AWEsh += (np.float32(MBSRN) * AWE_param2)
            MBSRN_out = driver.Create( "MBSRN.tif", shape[1], shape[0], 1, gdal.GDT_UInt32)
            MBSRN_out.SetGeoTransform( geo )
            MBSRN_out.SetProjection( proj ) 
            MBSRN_out.GetRasterBand(1).WriteArray(MBSRN)
            MBSRN_out=None
            SWIR2B= gdal.Open(SWIR2)
            SWIR2B= SWIR2B.GetRasterBand(1).ReadAsArray()
            con_AWEsh += (np.float32(SWIR2B) * AWE_param3)
            BlueB= gdal.Open(Blue)
            BlueB= BlueB.GetRasterBand(1).ReadAsArray()
            con_AWEsh += np.float32(BlueB)
            con_AWEsh[con_AWEsh > 0] = 100
            con_AWEsh[con_AWEsh <= 0] = 0
            con_AWEsh=np.int8(con_AWEsh)
            #Optional to output AWEsh test
            #con_AWEsh_out = driver.Create( "con_AWEsh.tif", shape[1], shape[0], 1, gdal.GDT_UInt16)
            #con_AWEsh_out.SetGeoTransform( geo )
            #con_AWEsh_out.SetProjection( proj ) 
            #con_AWEsh_out.GetRasterBand(1).WriteArray(con_AWEsh)
            #con_AWEsh_out=None


            # Perform Partial Surface Water test 1 (PSW1)-working
            con_PSW1_MNDWI=((GreenB - SWIR1B) /np.float32(GreenB + SWIR1B))

            con_PSW1_MNDWI[con_PSW1_MNDWI > PSW1_MNDWI] = 1
            con_PSW1_MNDWI[con_PSW1_MNDWI <= PSW1_MNDWI] = 0
            con_PSW1_MNDWI=np.int8(con_PSW1_MNDWI)
            NIRB[NIRB < PSW1_NIR] = 1
            NIRB[NIRB >= PSW1_NIR] = 0
            PSW1= np.int8(con_PSW1_MNDWI) * np.int8(NIRB)
            PSW1_SWIR1B=SWIR1B.copy()
            PSW1_SWIR1B[PSW1_SWIR1B < PSW1_SWIR1] = 1
            PSW1_SWIR1B[PSW1_SWIR1B >= PSW1_SWIR1] = 0
            PSW1= np.int8(PSW1) * np.int8(PSW1_SWIR1B)
            del PSW1_SWIR1B
            
            # Calculate NDVI
            NIRB= gdal.Open(NIR)
            NIRB= NIRB.GetRasterBand(1).ReadAsArray()            
            NDVI = ((NIRB - RedB) /np.float32(NIRB + RedB))
            con_NDVI=np.zeros(shape)
            con_NDVI[NDVI < PSW1_NDVI] = 1
            PSW1= np.int16(PSW1) * np.int16(con_NDVI) * 1000
            #Optional to output PSW1 test
            #PSW1_out = driver.Create( "PSW1.tif", shape[1], shape[0], 1, gdal.GDT_UInt16)
            #PSW1_out.SetGeoTransform( geo )
            #PSW1_out.SetProjection( proj ) 
            #PSW1_out.GetRasterBand(1).WriteArray(PSW1)
            #PSW1_out=None
            
            #Perform PSW2 test- working
            con_PSW2_MNDWI=((GreenB - SWIR1B) /np.float32(GreenB + SWIR1B))
            con_PSW2_MNDWI[con_PSW2_MNDWI > PSW2_MNDWI] = 1
            con_PSW2_MNDWI[con_PSW2_MNDWI <= PSW2_MNDWI] = 0
            con_PSW2_MNDWI=np.int8(con_PSW2_MNDWI)
            BlueB[BlueB < PSW2_BLUE] = 1
            BlueB[BlueB >= PSW2_BLUE] = 0
            BlueB=np.int8(BlueB) 
            NIRB[NIRB < PSW2_NIR] = 1
            NIRB[NIRB >= PSW2_NIR] = 0
            NIRB=np.int8(NIRB)
            SWIR1B[SWIR1B < PSW2_SWIR1] = 1
            SWIR1B[SWIR1B >= PSW2_SWIR1] = 0
            SWIR1B=np.int8(SWIR1B) 
            SWIR2B[SWIR2B < PSW2_SWIR2] = 1
            SWIR2B[SWIR2B >= PSW2_SWIR2] = 0
            SWIR2B=np.int8(SWIR2B)
            PSW2= con_PSW2_MNDWI * BlueB * NIRB * SWIR1B *  SWIR2B * 10000
            #Optional to output PSW2 test
            #PSW2_out = driver.Create( "PSW2.tif", shape[1], shape[0], 1, gdal.GDT_UInt16)
            #PSW2_out.SetGeoTransform( geo )
            #PSW2_out.SetProjection( proj ) 
            #PSW2_out.GetRasterBand(1).WriteArray(PSW2)
            #PSW2_out=None
            del GreenB, SWIR1B, MNDWI, RedB, NIRB, MBSRN, SWIR2B, BlueB, con_PSW1_MNDWI, con_NDVI, con_PSW2_MNDWI
            diagmap= con_MNDWI + con_MBSR + con_AWEsh + PSW1 + PSW2
            del con_MNDWI, con_MBSR, con_AWEsh, PSW1, PSW2
            
            os.chdir(input_dir)

            
            # Terrain Correction, here we are simply recoding slopes >=x degrees to PS (specified above), which will be reclassified as non-water.

            perslp = gdal.Open(Perslp)
            #Get extent and projection
            perslpgeo = perslp.GetGeoTransform()
            perslpproj = perslp.GetProjection()
            # Calculate percent slope
            #perslp= perslp.GetRasterBand(1).ReadAsArray()
            os.chdir(working_dir)
            CF = gdal.Open(CF)
            #Get extent of CF mask (and our LS image by proxy)
            geoTransform = CF.GetGeoTransform()
            minx = geoTransform[0]
            maxy = geoTransform[3]
            maxx = minx + geoTransform[1] * CF.RasterXSize
            miny = maxy + geoTransform[5] * CF.RasterYSize
            #Clip our slope and hillshade mask to the image (have to do this for each image due to the variable extents of each image)
            GeoClip= [minx, maxy, maxx, miny]
            print GeoClip
            hillshade= gdal.Open(Hillshade)
            perslp_clip=gdal.Translate('perslp_clip.tif', perslp, projWin = GeoClip)
            hillshade_clip=gdal.Translate('hillshade_clip.tif', hillshade, projWin = GeoClip)
            hillshade= hillshade_clip.GetRasterBand(1).ReadAsArray()
            hillshade[hillshade <= HS] = 0
            hillshade[hillshade > HS] = 1
            
            #Read in the slope and hillshade masks and convert to an array
            workingoutput_dir=output_dir2 + "\\" + directory
            if not os.path.exists(workingoutput_dir):
                os.makedirs(workingoutput_dir)
                
            #calculate our unmasked diagnostic map
            CF= CF.GetRasterBand(1).ReadAsArray()
            diagoutput=output_dir2 +  "\\" + directory + "\\" + out_name + "_diag" + "_%s.tif"%"_".join(raster.split('_'))[0:length]
            diagmap[np.where((CF == 255))] = -9999
            diagmap_out = driver.Create( diagoutput, shape[1], shape[0], 1, gdal.GDT_Int16)
            diagmap_out.SetGeoTransform( geo )
            diagmap_out.SetProjection( proj )
            diagmap_out.GetRasterBand(1).WriteArray(diagmap)
            diagmap_out.GetRasterBand(1).SetNoDataValue(-9999)
                
            
            # Output unmasked interpreted map
            interpoutput=output_dir2 +  "\\" + directory + "\\" + out_name + "_interp" + "_%s.tif"%"_".join(raster.split('_'))[0:length]
            interpmap=diagmap.copy()
            interpmap[np.where((diagmap == 0) | (diagmap == 1) | (diagmap == 10) | (diagmap == 100) | (diagmap == 1000))] = 0
            interpmap[np.where((diagmap == 1111) | (diagmap == 10111) | (diagmap == 11011) | (diagmap == 11101) | (diagmap == 11110) | (diagmap == 11111)) ] = 1
            interpmap[np.where((diagmap == 111) | (diagmap == 1011) | (diagmap == 1101) | (diagmap == 1110) | (diagmap == 10011) | (diagmap == 10101) | (diagmap == 10110) | (diagmap == 11001) | (diagmap == 11010) | (diagmap == 11100)) ] = 2
            interpmap[np.where((diagmap == 11000)) ] = 3
            interpmap[np.where((diagmap == 11) | (diagmap == 101) | (diagmap == 110) | (diagmap == 1001) | (diagmap == 1010) | (diagmap == 1100) | (diagmap == 10000) | (diagmap == 10001) | (diagmap == 10010) | (diagmap == 10100)) ] = 4
            interpmap[np.where((diagmap == -9999)) ] = 255
            interpmap_out = driver.Create( interpoutput, shape[1], shape[0], 1, gdal.GDT_Byte)
            interpmap_out.SetGeoTransform( geo )
            interpmap_out.SetProjection( proj )
            interpmap_out.GetRasterBand(1).WriteArray(interpmap)
            interpmap_out.GetRasterBand(1).SetNoDataValue(255)


            # Mask interpreted map using the slope file
            perslp= perslp_clip.GetRasterBand(1).ReadAsArray()
            interpmap_copy=interpmap.copy()
            interpmap[np.where((perslp >= 30) & (interpmap == 2))] = 0
            interpmap[np.where((perslp >= 20) & (interpmap == 3))] = 0
            interpmap[np.where((perslp >= 10) & (interpmap == 4))] = 0
            interpmap[np.where((perslp >= 30) & (interpmap == 1))] = 0
            interpmap_masked= interpmap * hillshade           

   
            
            #Cloud and snow masking and outputing masked interpreted layer
            interpmaskoutput=output_dir2 +  "\\" + directory + "\\" + out_name + "_interp_masked" + "_%s.tif"%"_".join(raster.split('_'))[0:length]
            interpmap_masked=interpmap_masked.copy()
            interpmap_masked[np.where((CF == 255))] = 255
            interpmap_masked[np.where((CF >= 2) & (CF < 255))] = 9
            interpmap_masked_out = driver.Create( interpmaskoutput, shape[1], shape[0], 1, gdal.GDT_Byte)
            interpmap_masked_out.SetGeoTransform( geo )
            interpmap_masked_out.SetProjection( proj )
            interpmap_masked_out.GetRasterBand(1).WriteArray(interpmap_masked)
            interpmap_masked_out.GetRasterBand(1).SetNoDataValue(255)
            del interpmap_masked_out
            del diagmap
            del interpmap



            #Create a full mask layer
            CF[np.where((CF == 1)) ] = 0
            perslp[np.where((perslp < 10) & (interpmap_copy == 4)) ] = 0
            perslp[np.where((perslp < 20) & (interpmap_copy == 3)) ] = 0
            perslp[np.where((perslp < 30) & (interpmap_copy == 2)) ] = 0
            perslp[np.where((perslp < 30) & (interpmap_copy == 1)) ] = 0
            perslp[np.where((perslp >= 10) & (interpmap_copy == 4)) ] = 10
            perslp[np.where((perslp >= 20) & (interpmap_copy == 3)) ] = 10
            perslp[np.where((perslp >= 30) & (interpmap_copy == 2)) ] = 10
            perslp[np.where((perslp >= 30) & (interpmap_copy == 1)) ] = 10
            perslp[np.where((interpmap_copy == 0)) ] = 0       
            hillshade[np.where((hillshade == 0)) ] = 20
            hillshade[np.where((hillshade == 1)) ] = 0
            MaskLayer=CF + perslp + hillshade
            MaskLayerOut=output_dir2 +  "\\" + directory + "\\" + out_name + "_MaskLayer" + "_%s.tif"%"_".join(raster.split('_'))[0:length]
            MaskLayer[np.where((CF == 255))] = 255
            MaskLayer_Output = driver.Create(MaskLayerOut, shape[1], shape[0], 1, gdal.GDT_Byte)
            MaskLayer_Output.SetGeoTransform( geo )
            MaskLayer_Output.SetProjection( proj )
            MaskLayer_Output.GetRasterBand(1).WriteArray(MaskLayer)
            MaskLayer_Output.GetRasterBand(1).SetNoDataValue(255)
            del hillshade_clip, hillshade, MaskLayer, CF, MaskLayerOut, MaskLayer_Output, diagoutput
            del Metadata, diagmap_out, interpmap_masked, interpmap_out, interpmaskoutput, interpoutput, perslp, perslp_clip           
            
            itemlist=["hillshade*.tif", "perslp*.tif"]
            for item in itemlist:
                i=glob.glob(item)
                for r in i:
                    os.remove(r)

           #Timer
            print datetime.datetime.now()
            T2=datetime.datetime.now()
            T3=T2-T1
            print T3
     
            if count == subdirnumber:
                break                  
            else:
                count=count+1
                print count

                    
                    

    

   
